/*
N*N의 섬나라 아일랜드의 지도가 격자판의 정보로 주어집니다. 각 섬은 1로 표시되어 상하좌
우와 대각선으로 연결되어 있으며, 0은 바다입니다. 섬나라 아일랜드에 몇 개의 섬이 있는지 
구하는 프로그램을 작성하세요.
1 1 0 0 0 1 0
0 1 1 0 1 1 0
0 1 0 0 0 0 0
0 0 0 1 0 1 1
1 1 0 1 1 0 0
1 0 0 0 1 0 0
1 0 1 0 1 0 0
만약 위와 같다면 

▣ 입력설명
첫 번째 줄에 자연수 N(3<=N<=20)이 주어집니다.
두 번째 줄부터 격자판 정보가 주어진다.
▣ 출력설명
첫 번째 줄에 섬의 개수를 출력한다.
▣ 입력예제 1 
7
1 1 0 0 0 1 0
0 1 1 0 1 1 0
0 1 0 0 0 0 0
0 0 0 1 0 1 1
1 1 0 1 1 0 0
1 0 0 0 1 0 0
1 0 1 0 1 0 0
▣ 출력예제 1
5
*/

/*
풀이
- 2중 for문을 이용해 배열을 순회하며 원소의 값이 1일 때 DFS를 호출한다.
- 배열의 각 요소마다 DFS를 이용해 인접한 위치가 섬인지 확인한다. (대각선 까지)
- DFS에서 한 요소를 방문하면 값을 0으로 바꿔 방문처리를 해준다.

*/

(function (arr) {
  let answer = 0;
  let n = arr.length;
  const dx = [-1, 0, 1, 1, 1, 0, -1, -1];
  const dy = [-1, -1, -1, 0, 1, 1, 1, 0];

  function DFS(x, y) {
    arr[x][y] = 0; //방문처리

    for (let i = 0; i < 8; i++) {
      const [nextX, nextY] = [x + dx[i], y + dy[i]];

      if (
        nextX < 0 ||
        nextX >= n ||
        nextY < 0 ||
        nextY >= n ||
        arr[nextX][nextY] === 0
      )
        continue;
      //continue를 해야 다른 섬이 존재하는지 확인이 가능

      DFS(nextX, nextY);
    }
  }

  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      if (arr[i][j] === 1) {
        answer++;
        console.log(i, j);
        DFS(i, j);
      }
    }
  }

  console.log(answer);
})([
  [1, 1, 0, 0, 0, 1, 0],
  [0, 1, 1, 0, 1, 1, 0],
  [0, 1, 0, 0, 0, 0, 0],
  [0, 0, 0, 1, 0, 1, 1],
  [1, 1, 0, 1, 1, 0, 0],
  [1, 0, 0, 0, 1, 0, 0],
  [1, 0, 1, 0, 1, 0, 0],
]);
