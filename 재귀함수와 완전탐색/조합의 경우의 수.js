/*
조합의 경우수(메모이제이션)
여러분은 이 공식을 쓰지않고 다음 공식을 사용하여 
재귀를 이용해 조합수를 구해주는 프로그램을 작성하세요. 
nCr = n-1Cr-1 + n-1Cr
▣ 입력설명
첫째 줄에 자연수 n(3<=n<=33)과 r(0<=r<=n)이 입력됩니다.
▣ 출력설명
첫째 줄에 조합수를 출력합니다.
▣ 입력예제 1 
5 3
▣ 출력예제 1
10
▣ 입력예제 2 
33 19
▣ 출력예제 2
818809200
*/
/*
해설
nCr = n-1Cr-1 + n-1Cr 이므로 n과 r을 매개변수로 하여 재귀를 구현한다.
이 공식의 뜻은 n개의 원소 중 1개의 원소를 선택했을 때, 
나머지 원소에서 r-1개를 선택한 경우와,
선택한 원소를 제외하고 나머지 n-1개 중 r개를 선택했을 때를 더한 것이다.
        5C3
     4C2 + 4C3
   3C1+3C2 3C2+3C3
   ...
이렇게 진행된다.
xC0 이거나 xCx가 되면 경우의 수가 1이므로 이때 1을 반환하면 된다.

메모이제이션
- 기존의 방법은 왼쪽->부모->오른쪽 으로 연산하는 중위연산기법이다.
- 이미 계산했던 과정을 다른 쪽에서 다시 계산하는 이슈가 있다.
- 따라서 2차원 배열의 [n][r]에 해당 값을 저장하여 다음 연산 시 해당 자리에
값이 있으면 그 값을 사용하는 것이 훨씬 빠르다. (인덱스로 접근하면 O(1)의 시간이 걸리기때문)
*/

(function solution(n, r) {
  let answer;
  let arr = Array.from(Array(n + 1), () => Array(r + 1).fill(0));

  function DFS(n, r) {
    if (arr[n][r] > 0) return arr[n][r]; //값이 있다면 그 값을 사용
    if (n === r || r === 0) return 1;
    return (arr[n][r] = DFS(n - 1, r - 1) + DFS(n - 1, r)); // 계산과 동시에 배열에 값을 저장
  }
  answer = DFS(n, r);
  console.log(answer);
})(33, 19);
