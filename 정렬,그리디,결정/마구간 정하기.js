/*
N개의 마구간이 수직선상에 있습니다. 각 마구간은 x1, x2, x3, ......, xN의 좌표를 가지며, 마
구간간에 좌표가 중복되는 일은 없습니다.
현수는 C마리의 말을 가지고 있는데, 이 말들은 서로 가까이 있는 것을 좋아하지 않습니다. 
각 마구간에는 한 마리의 말만 넣을 수 있고, 가장 가까운 두 말의 거리가 최대가 되게 말을 
마구간에 배치하고 싶습니다. 
C마리의 말을 N개의 마구간에 배치했을 때 가장 가까운 두 말의 거리가 최대가 되는 그 최대
값을 출력하는 프로그램을 작성하세요.

▣ 입력설명
첫 줄에 자연수 N(3<=N<=200,000)과 C(2<=C<=N)이 공백을 사이에 두고 주어집니다.
둘째 줄에 마구간의 좌표 xi(0<=xi<=1,000,000,000)가 차례로 주어집니다.
▣ 출력설명
첫 줄에 가장 가까운 두 말의 최대 거리를 출력하세요.
▣ 입력예제 1 
5 3
1 2 8 4 9
▣ 출력예제 1
3
*/
/*
해설
- C마리 만큼 배치할 수 있는 경우 중 인접한 마굿간의 거리가 최대일 경우를 구하라.

풀이
- 먼저 기존 배열을 정렬한다.
- lt와 rt를 1, 배열의 최댓값으로 정의한다. (마굿간의 거리임)
- 반복문을 통해 마굿간의 거리대로 말을 배치했을 때 말의 마리수를 검사한다.
- 마리수가 C마리와 같다면, 같은 경우가 여러개 있을 수 있으므로 lt를 mid+1로 변경한다.
- 마리수가 C마리보다 크다면, 거리를 늘려야하므로 lt를 mid+1로 변경한다.
- 마리수가 C마리보다 작다면, 거리를 좁혀야하므로 rt를 mid-1로 변경한다.
*/
function horse(mid, arr) {
  let cnt = 1; //처음 말을 배치하고 시작
  let target = arr[0]; //비교 대상 지정
  for (let i = 1; i < arr.length - 1; i++) {
    if (arr[i] - target >= mid) {
      //기준 마굿간과의 거리가 mid보다 크거나 같다면
      cnt++;
      target = arr[i]; //기준 변경
    }
  }

  return cnt;
}
(function solution(n, c, arr) {
  let lt = 1; //마굿간의 최소 거리
  let rt = Math.max(...arr); //마굿간의 최대 거리
  let answer = 0;
  arr.sort((a, b) => a - b);

  while (lt <= rt) {
    const mid = parseInt((lt + rt) / 2);

    if (horse(mid, arr) === c) {
      //c마리보다 같으면 (같은 경우가 여러개 일 수 있음)
      answer = mid;
      lt = mid + 1;
    } else if (horse(mid, arr) > c) {
      //c마리보다 크면
      lt = mid + 1;
    } else {
      //c마리보다 적으면 거리를 좁혀야함
      rt = mid - 1;
    }
  }

  console.log(answer);
})(5, 3, [1, 2, 8, 4, 9]);
